import { Agent } from './base-agent';
import { AgentType, Task } from './types';

/**
 * CoderAgent - Writes and implements code solutions
 */
export class CoderAgent extends Agent {
    constructor() {
        super(AgentType.CODER, "Coder", "Writes and implements code solutions");
    }

    async processTask(task: Task, context?: any): Promise<string> {
        console.log(`[Coder] Processing task: ${task.description}`);
        
        const description = task.description.toLowerCase();
        let generatedCode = '';
        let filename = '';
        
        try {
            if (description.includes('function')) {
                const result = this.generateFunction(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            } else if (description.includes('class')) {
                const result = this.generateClass(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            } else if (description.includes('api') || description.includes('endpoint')) {
                const result = this.generateApiEndpoint(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            } else if (description.includes('component')) {
                const result = this.generateComponent(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            } else if (description.includes('interface') || description.includes('type')) {
                const result = this.generateInterface(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            } else {
                const result = this.generateGenericCode(task.description, context);
                generatedCode = result.code;
                filename = result.filename;
            }
            
            // Write the generated code to a file
            if (generatedCode && filename) {
                await this.writeCodeToFile(filename, generatedCode, context);
                return `✅ Generated ${filename}:\n\`\`\`${this.getFileExtension(filename)}\n${generatedCode}\n\`\`\`\n\nFile written to workspace.`;
            } else {
                return `⚠️ Could not generate specific code for: ${task.description}`;
            }
        } catch (error) {
            return `❌ Code generation failed: ${error}`;
        }
    }

    private generateFunction(description: string, context?: any): { code: string; filename: string } {
        const functionName = this.extractFunctionName(description);
        const language = this.detectLanguage(context);
        
        if (language === 'typescript' || language === 'javascript') {
            const code = `/**
 * ${description}
 * Generated by CoderAgent
 */
export function ${functionName}(/* parameters */): /* return type */ {
    // TODO: Implement function logic
    throw new Error('Function not implemented');
}

// Example usage:
// const result = ${functionName}(/* arguments */);
// console.log(result);`;
            
            return {
                code,
                filename: `src/${functionName}.${language === 'typescript' ? 'ts' : 'js'}`
            };
        } else if (language === 'python') {
            const code = `"""
${description}
Generated by CoderAgent
"""

def ${functionName}():
    """
    TODO: Add function documentation
    
    Returns:
        TODO: Specify return type and description
    """
    # TODO: Implement function logic
    raise NotImplementedError("Function not implemented")

# Example usage:
# result = ${functionName}()
# print(result)`;
            
            return {
                code,
                filename: `${functionName}.py`
            };
        }
        
        return { code: `// ${description}\n// TODO: Implement function`, filename: `${functionName}.txt` };
    }

    private generateClass(description: string, context?: any): { code: string; filename: string } {
        const className = this.extractClassName(description);
        const language = this.detectLanguage(context);
        
        if (language === 'typescript') {
            const code = `/**
 * ${description}
 * Generated by CoderAgent
 */
export class ${className} {
    private _initialized: boolean = false;

    constructor() {
        // TODO: Initialize class properties
        this._initialized = true;
    }

    /**
     * TODO: Add method documentation
     */
    public someMethod(): void {
        if (!this._initialized) {
            throw new Error('${className} not initialized');
        }
        // TODO: Implement method logic
    }

    /**
     * Get the initialization status
     */
    public get isInitialized(): boolean {
        return this._initialized;
    }
}

// Example usage:
// const instance = new ${className}();
// instance.someMethod();`;
            
            return {
                code,
                filename: `src/${className}.ts`
            };
        } else if (language === 'python') {
            const code = `"""
${description}
Generated by CoderAgent
"""

class ${className}:
    """
    TODO: Add class documentation
    """
    
    def __init__(self):
        """Initialize the ${className} instance."""
        self._initialized = True
    
    def some_method(self):
        """
        TODO: Add method documentation
        """
        if not self._initialized:
            raise RuntimeError("${className} not initialized")
        # TODO: Implement method logic
        pass
    
    @property
    def is_initialized(self) -> bool:
        """Get the initialization status."""
        return self._initialized

# Example usage:
# instance = ${className}()
# instance.some_method()`;
            
            return {
                code,
                filename: `${className.toLowerCase()}.py`
            };
        }
        
        return { code: `// ${description}\n// TODO: Implement class`, filename: `${className}.txt` };
    }

    private generateApiEndpoint(description: string, context?: any): { code: string; filename: string } {
        const endpointName = this.extractEndpointName(description);
        const language = this.detectLanguage(context);
        
        if (language === 'typescript' || language === 'javascript') {
            const code = `import express from 'express';

/**
 * ${description}
 * Generated by CoderAgent
 */

// Router setup
const router = express.Router();

// GET endpoint
router.get('/${endpointName}', async (req, res) => {
    try {
        // TODO: Implement GET logic
        const result = {
            message: 'Success',
            data: null
        };
        
        res.json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// POST endpoint  
router.post('/${endpointName}', async (req, res) => {
    try {
        const { body } = req;
        
        // TODO: Validate request body
        // TODO: Implement POST logic
        
        const result = {
            message: '${endpointName} created successfully',
            data: body
        };
        
        res.status(201).json(result);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

export default router;`;
            
            return {
                code,
                filename: `src/routes/${endpointName}.${language === 'typescript' ? 'ts' : 'js'}`
            };
        }
        
        return { code: `// ${description}\n// TODO: Implement API endpoint`, filename: `${endpointName}_api.txt` };
    }

    private generateComponent(description: string, context?: any): { code: string; filename: string } {
        const componentName = this.extractComponentName(description);
        
        if (description.includes('react')) {
            const code = `import React, { useState, useEffect } from 'react';

/**
 * ${description}
 * Generated by CoderAgent
 */

interface ${componentName}Props {
    // TODO: Define component props
    className?: string;
}

export const ${componentName}: React.FC<${componentName}Props> = ({ 
    className = ''
}) => {
    const [state, setState] = useState<any>(null);

    useEffect(() => {
        // TODO: Add component lifecycle logic
    }, []);

    const handleAction = () => {
        // TODO: Implement action handler
    };

    return (
        <div className={\`${componentName.toLowerCase()} \${className}\`}>
            <h2>${componentName}</h2>
            {/* TODO: Add component JSX */}
            <button onClick={handleAction}>
                Action
            </button>
        </div>
    );
};

export default ${componentName};`;
            
            return {
                code,
                filename: `src/components/${componentName}.tsx`
            };
        }
        
        return { code: `<!-- ${description} -->\n<!-- TODO: Implement component -->`, filename: `${componentName}.html` };
    }

    private generateInterface(description: string, context?: any): { code: string; filename: string } {
        const interfaceName = this.extractInterfaceName(description);
        
        const code = `/**
 * ${description}
 * Generated by CoderAgent
 */

export interface ${interfaceName} {
    // TODO: Define interface properties
    id: string;
    name: string;
    createdAt: Date;
    updatedAt?: Date;
}

// Example implementation
export class ${interfaceName}Impl implements ${interfaceName} {
    constructor(
        public id: string,
        public name: string,
        public createdAt: Date = new Date(),
        public updatedAt?: Date
    ) {}
}`;
        
        return {
            code,
            filename: `src/types/${interfaceName}.ts`
        };
    }

    private generateGenericCode(description: string, context?: any): { code: string; filename: string } {
        const language = this.detectLanguage(context);
        const filename = this.generateFilename(description, language);
        
        if (language === 'typescript') {
            const code = `/**
 * ${description}
 * Generated by CoderAgent
 */

// TODO: Implement the requested functionality
export const implementation = {
    // Add your implementation here
};

export default implementation;`;
            
            return { code, filename };
        }
        
        return { 
            code: `// ${description}\n// TODO: Implement requested functionality`, 
            filename 
        };
    }

    private async writeCodeToFile(filename: string, code: string, context?: any): Promise<void> {
        // In a real VS Code extension, this would use the actual file system
        // For now, we'll simulate writing to the workspace
        console.log(`[CoderAgent] Writing code to ${filename}`);
        
        // TODO: Integrate with actual VS Code file system API
        // await vscode.workspace.fs.writeFile(vscode.Uri.file(filename), Buffer.from(code));
    }

    private extractFunctionName(description: string): string {
        const match = description.match(/function\s+(\w+)|(\w+)\s+function/i);
        return match ? (match[1] || match[2]) : 'generatedFunction';
    }

    private extractClassName(description: string): string {
        const match = description.match(/class\s+(\w+)|(\w+)\s+class/i);
        return match ? (match[1] || match[2]) : 'GeneratedClass';
    }

    private extractEndpointName(description: string): string {
        const match = description.match(/(\w+)\s+(?:api|endpoint)|(?:api|endpoint)\s+(\w+)/i);
        return match ? (match[1] || match[2]) : 'generated';
    }

    private extractComponentName(description: string): string {
        const match = description.match(/(\w+)\s+component|component\s+(\w+)/i);
        return match ? (match[1] || match[2]) : 'GeneratedComponent';
    }

    private extractInterfaceName(description: string): string {
        const match = description.match(/interface\s+(\w+)|(\w+)\s+interface/i);
        return match ? (match[1] || match[2]) : 'GeneratedInterface';
    }

    private detectLanguage(context?: any): string {
        if (!context) {
            return 'typescript';
        }
        
        const projectType = context.projectType?.toLowerCase();
        if (projectType === 'python') {
            return 'python';
        }
        if (projectType === 'nodejs') {
            return 'typescript';
        }
        if (projectType === 'javascript') {
            return 'javascript';
        }
        
        return 'typescript';
    }

    private generateFilename(description: string, language: string): string {
        const baseName = description.toLowerCase().replace(/[^a-zA-Z0-9]/g, '_').substring(0, 30);
        const extension = language === 'python' ? 'py' : language === 'javascript' ? 'js' : 'ts';
        return `src/${baseName}.${extension}`;
    }

    private getFileExtension(filename: string): string {
        const ext = filename.split('.').pop()?.toLowerCase();
        switch (ext) {
            case 'ts': return 'typescript';
            case 'js': return 'javascript';
            case 'py': return 'python';
            case 'tsx': return 'tsx';
            default: return 'text';
        }
    }
}
