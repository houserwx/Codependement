import { Agent } from './base-agent';
import { AgentType, Task } from './types';

/**
 * TesterAgent - Creates and runs tests to validate functionality
 */
export class TesterAgent extends Agent {
    constructor() {
        super(AgentType.TESTER, "Tester", "Creates and runs tests to validate functionality");
    }

    async processTask(task: Task, context?: any): Promise<string> {
        console.log(`[Tester] Processing task: ${task.description}`);
        
        try {
            const language = this.detectLanguage(context);
            const testType = this.determineTestType(task.description);
            
            let testCode = '';
            let filename = '';
            let testResults = '';

            switch (testType) {
                case 'unit':
                    const unitTest = this.generateUnitTest(task.description, context, language);
                    testCode = unitTest.code;
                    filename = unitTest.filename;
                    break;
                case 'integration':
                    const integrationTest = this.generateIntegrationTest(task.description, context, language);
                    testCode = integrationTest.code;
                    filename = integrationTest.filename;
                    break;
                case 'component':
                    const componentTest = this.generateComponentTest(task.description, context);
                    testCode = componentTest.code;
                    filename = componentTest.filename;
                    break;
                default:
                    const genericTest = this.generateGenericTest(task.description, context, language);
                    testCode = genericTest.code;
                    filename = genericTest.filename;
            }

            // Write test file
            if (testCode && filename) {
                await this.writeTestToFile(filename, testCode, context);
                
                // Simulate running tests
                testResults = this.simulateTestExecution(testType, task.description);
                
                return `✅ Generated test file: ${filename}\n\n\`\`\`${this.getFileExtension(filename)}\n${testCode}\n\`\`\`\n\n📊 **Test Results:**\n${testResults}`;
            } else {
                return `⚠️ Could not generate specific tests for: ${task.description}`;
            }
        } catch (error) {
            return `❌ Test generation failed: ${error}`;
        }
    }

    private generateUnitTest(description: string, context?: any, language: string = 'typescript'): { code: string; filename: string } {
        const targetName = this.extractTargetName(description);
        
        if (language === 'typescript' || language === 'javascript') {
            const isTs = language === 'typescript';
            const code = `${isTs ? "import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';" : "const { describe, it, expect, beforeEach, afterEach } = require('@jest/globals');"}
${isTs ? `import { ${targetName} } from '../src/${targetName}';` : `const { ${targetName} } = require('../src/${targetName}');`}

/**
 * Unit tests for ${targetName}
 * Generated by TesterAgent for: ${description}
 */

describe('${targetName}', () => {
    let instance${isTs ? `: ${targetName}` : ''};

    beforeEach(() => {
        // Setup before each test
        instance = new ${targetName}();
    });

    afterEach(() => {
        // Cleanup after each test
        instance = null;
    });

    describe('Constructor', () => {
        it('should create instance successfully', () => {
            expect(instance).toBeDefined();
            expect(instance).toBeInstanceOf(${targetName});
        });

        it('should initialize with default values', () => {
            // TODO: Add specific initialization tests
            expect(instance.isInitialized).toBe(true);
        });
    });

    describe('Core Functionality', () => {
        it('should perform main operation correctly', async () => {
            // TODO: Test main functionality
            const result = await instance.someMethod();
            expect(result).toBeDefined();
        });

        it('should handle edge cases', () => {
            // TODO: Test edge cases
            expect(() => {
                instance.someMethod();
            }).not.toThrow();
        });

        it('should validate input parameters', () => {
            // TODO: Test input validation
            expect(() => {
                instance.someMethod(null);
            }).toThrow();
        });
    });

    describe('Error Handling', () => {
        it('should handle errors gracefully', () => {
            // TODO: Test error scenarios
            expect(() => {
                instance.someMethod('invalid');
            }).toThrow('Expected error message');
        });
    });
});`;

            return {
                code,
                filename: `tests/${targetName}.test.${isTs ? 'ts' : 'js'}`
            };
        } else if (language === 'python') {
            const code = `"""
Unit tests for ${targetName}
Generated by TesterAgent for: ${description}
"""

import unittest
from unittest.mock import Mock, patch
import sys
import os

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))

from ${targetName.toLowerCase()} import ${targetName}


class Test${targetName}(unittest.TestCase):
    """Test cases for ${targetName} class."""

    def setUp(self):
        """Set up test fixtures before each test method."""
        self.instance = ${targetName}()

    def tearDown(self):
        """Clean up after each test method."""
        self.instance = None

    def test_initialization(self):
        """Test that ${targetName} initializes correctly."""
        self.assertIsNotNone(self.instance)
        self.assertTrue(self.instance.is_initialized)

    def test_main_functionality(self):
        """Test the main functionality of ${targetName}."""
        # TODO: Implement main functionality test
        result = self.instance.some_method()
        self.assertIsNotNone(result)

    def test_edge_cases(self):
        """Test edge cases and boundary conditions."""
        # TODO: Implement edge case tests
        with self.assertRaises(ValueError):
            self.instance.some_method(None)

    def test_error_handling(self):
        """Test error handling scenarios."""
        # TODO: Implement error handling tests
        with self.assertRaises(RuntimeError):
            # Test uninitialized state
            uninitialied_instance = ${targetName}()
            uninitialied_instance._initialized = False
            uninitialied_instance.some_method()

    @patch('${targetName.toLowerCase()}.some_dependency')
    def test_with_mocks(self, mock_dependency):
        """Test with mocked dependencies."""
        # TODO: Implement tests with mocks
        mock_dependency.return_value = "mocked_result"
        result = self.instance.some_method()
        self.assertEqual(result, "expected_result")


if __name__ == '__main__':
    unittest.main()`;

            return {
                code,
                filename: `tests/test_${targetName.toLowerCase()}.py`
            };
        }

        return { code: `# ${description}\n# TODO: Generate tests`, filename: `test_${targetName}.txt` };
    }

    private generateIntegrationTest(description: string, context?: any, language: string = 'typescript'): { code: string; filename: string } {
        const targetName = this.extractTargetName(description);
        
        if (language === 'typescript') {
            const code = `import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';
import request from 'supertest';
import { app } from '../src/app';

/**
 * Integration tests for ${targetName}
 * Generated by TesterAgent for: ${description}
 */

describe('${targetName} Integration Tests', () => {
    beforeAll(async () => {
        // Setup test environment
        process.env.NODE_ENV = 'test';
    });

    afterAll(async () => {
        // Cleanup test environment
    });

    describe('API Endpoints', () => {
        it('should handle GET requests', async () => {
            const response = await request(app)
                .get('/${targetName.toLowerCase()}')
                .expect(200);

            expect(response.body).toBeDefined();
            expect(response.body.message).toBe('Success');
        });

        it('should handle POST requests', async () => {
            const testData = {
                name: 'Test Item',
                description: 'Test Description'
            };

            const response = await request(app)
                .post('/${targetName.toLowerCase()}')
                .send(testData)
                .expect(201);

            expect(response.body.data).toMatchObject(testData);
        });

        it('should handle PUT requests', async () => {
            const updateData = {
                name: 'Updated Item'
            };

            const response = await request(app)
                .put('/${targetName.toLowerCase()}/1')
                .send(updateData)
                .expect(200);

            expect(response.body.data.name).toBe(updateData.name);
        });

        it('should handle DELETE requests', async () => {
            await request(app)
                .delete('/${targetName.toLowerCase()}/1')
                .expect(204);
        });
    });

    describe('Database Integration', () => {
        it('should persist data correctly', async () => {
            // TODO: Test database operations
        });

        it('should handle database errors', async () => {
            // TODO: Test database error scenarios
        });
    });

    describe('External Service Integration', () => {
        it('should communicate with external services', async () => {
            // TODO: Test external service calls
        });
    });
});`;

            return {
                code,
                filename: `tests/integration/${targetName}.integration.test.ts`
            };
        }

        return { code: `# ${description}\n# TODO: Generate integration tests`, filename: `integration_test_${targetName}.txt` };
    }

    private generateComponentTest(description: string, context?: any): { code: string; filename: string } {
        const componentName = this.extractTargetName(description);
        
        const code = `import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ${componentName} } from '../src/components/${componentName}';

/**
 * Component tests for ${componentName}
 * Generated by TesterAgent for: ${description}
 */

describe('${componentName}', () => {
    const defaultProps = {
        // TODO: Define default props
    };

    beforeEach(() => {
        // Setup before each test
    });

    describe('Rendering', () => {
        it('should render without crashing', () => {
            render(<${componentName} {...defaultProps} />);
            expect(screen.getByRole('heading')).toBeInTheDocument();
        });

        it('should render with correct content', () => {
            render(<${componentName} {...defaultProps} />);
            expect(screen.getByText('${componentName}')).toBeInTheDocument();
        });

        it('should apply custom className', () => {
            const customClass = 'custom-class';
            render(<${componentName} {...defaultProps} className={customClass} />);
            
            const component = screen.getByText('${componentName}').closest('div');
            expect(component).toHaveClass(customClass);
        });
    });

    describe('User Interactions', () => {
        it('should handle button clicks', async () => {
            const user = userEvent.setup();
            render(<${componentName} {...defaultProps} />);
            
            const button = screen.getByRole('button', { name: /action/i });
            await user.click(button);
            
            // TODO: Assert expected behavior
        });

        it('should handle form submissions', async () => {
            const user = userEvent.setup();
            render(<${componentName} {...defaultProps} />);
            
            // TODO: Test form interactions
        });
    });

    describe('State Management', () => {
        it('should update state correctly', async () => {
            render(<${componentName} {...defaultProps} />);
            
            // TODO: Test state changes
            await waitFor(() => {
                // Assert state changes
            });
        });
    });

    describe('Props Handling', () => {
        it('should handle prop changes', () => {
            const { rerender } = render(<${componentName} {...defaultProps} />);
            
            const newProps = { ...defaultProps, someProp: 'new value' };
            rerender(<${componentName} {...newProps} />);
            
            // TODO: Assert prop changes
        });
    });

    describe('Error Boundaries', () => {
        it('should handle errors gracefully', () => {
            // TODO: Test error scenarios
        });
    });
});`;

        return {
            code,
            filename: `tests/components/${componentName}.test.tsx`
        };
    }

    private generateGenericTest(description: string, context?: any, language: string = 'typescript'): { code: string; filename: string } {
        const targetName = this.extractTargetName(description);
        
        const code = `/**
 * Tests for ${targetName}
 * Generated by TesterAgent for: ${description}
 */

describe('${targetName}', () => {
    it('should work correctly', () => {
        // TODO: Implement test logic
        expect(true).toBe(true);
    });
    
    it('should handle edge cases', () => {
        // TODO: Test edge cases
    });
    
    it('should validate input', () => {
        // TODO: Test input validation
    });
});`;

        return {
            code,
            filename: `tests/${targetName}.test.${language === 'python' ? 'py' : 'ts'}`
        };
    }

    private determineTestType(description: string): 'unit' | 'integration' | 'component' | 'generic' {
        const desc = description.toLowerCase();
        
        if (desc.includes('integration') || desc.includes('api') || desc.includes('endpoint')) {
            return 'integration';
        }
        if (desc.includes('component') || desc.includes('react')) {
            return 'component';
        }
        if (desc.includes('unit') || desc.includes('function') || desc.includes('class')) {
            return 'unit';
        }
        
        return 'generic';
    }

    private simulateTestExecution(testType: string, description: string): string {
        const testCount = Math.floor(Math.random() * 10) + 5; // 5-15 tests
        const passRate = 0.85 + Math.random() * 0.1; // 85-95% pass rate
        const passed = Math.floor(testCount * passRate);
        const failed = testCount - passed;
        const coverage = Math.floor(Math.random() * 20) + 75; // 75-95% coverage
        const executionTime = Math.floor(Math.random() * 500) + 100; // 100-600ms
        
        let result = `**Test Suite: ${testType.toUpperCase()}**\n`;
        result += `Tests Run: ${testCount}\n`;
        result += `✅ Passed: ${passed}\n`;
        result += `❌ Failed: ${failed}\n`;
        result += `📊 Coverage: ${coverage}%\n`;
        result += `⏱️ Execution Time: ${executionTime}ms\n`;
        
        if (failed > 0) {
            result += `\n**Failed Tests:**\n`;
            for (let i = 1; i <= failed; i++) {
                result += `- Test ${i}: Expected behavior not met\n`;
            }
        }
        
        return result;
    }

    private async writeTestToFile(filename: string, code: string, context?: any): Promise<void> {
        console.log(`[TesterAgent] Writing test to ${filename}`);
        // TODO: Integrate with actual VS Code file system API
    }

    private extractTargetName(description: string): string {
        // Extract class/function/component name from description
        const patterns = [
            /(?:test|testing)\s+(\w+)/i,
            /(\w+)\s+(?:test|testing)/i,
            /for\s+(\w+)/i,
            /(\w+)(?:\s+class|\s+function|\s+component)/i
        ];
        
        for (const pattern of patterns) {
            const match = description.match(pattern);
            if (match) {
                return match[1];
            }
        }
        
        return 'Target';
    }

    private detectLanguage(context?: any): string {
        if (!context) {
            return 'typescript';
        }
        
        const projectType = context.projectType?.toLowerCase();
        if (projectType === 'python') {
            return 'python';
        }
        if (projectType === 'nodejs') {
            return 'typescript';
        }
        if (projectType === 'javascript') {
            return 'javascript';
        }
        
        return 'typescript';
    }

    private getFileExtension(filename: string): string {
        const ext = filename.split('.').pop()?.toLowerCase();
        switch (ext) {
            case 'ts': return 'typescript';
            case 'tsx': return 'tsx';
            case 'js': return 'javascript';
            case 'py': return 'python';
            default: return 'text';
        }
    }
}
